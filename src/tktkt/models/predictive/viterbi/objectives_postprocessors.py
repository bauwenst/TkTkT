from typing import List
from abc import ABC, abstractmethod

import numpy as np

from ....interfaces.tokeniser import Vocab
from .framework import ViterbiStepScoreGenerator, ViterbiStepScores, ViterbiStepScoreGeneratorWithTokens, ViterbiStepScoresWithTokens, INFTY


class NestedScoreGenerator(ViterbiStepScoreGenerator, ABC):

    def __init__(self, nested_generator: ViterbiStepScoreGenerator):
        self.nested_generator = nested_generator

    def generateGrid(self, string: str, max_k: int) -> ViterbiStepScores:
        nested_score = self.nested_generator.generateGrid(string, max_k)
        self.augmentScores(nested_score, string, max_k)
        return nested_score

    @abstractmethod
    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        """
        Modify the scores generated by the wrapped score generator IN-PLACE.

        There is no reason to not do it in-place because everything is stored in objects and only one grid is output,
        unless you want to e.g. return a grid of a different class. In that case, override generateGrid to do what you
        want and let augmentScores raise an exception (just in case).
        """
        pass


class ConvertToProbabilities(NestedScoreGenerator):

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        nested_scores.grid = np.exp(nested_scores.grid)  # e^ln(p) == p


class WithStrings(NestedScoreGenerator, ViterbiStepScoreGeneratorWithTokens):
    """
    Wrapper around a generator that annotates each step with (1) its step score and (2) the string of that step.
    """

    def generateGrid(self, string: str, max_k: int) -> ViterbiStepScoresWithTokens:
        old_grid = self.nested_generator.generateGrid(string, max_k)
        new_grid = ViterbiStepScoresWithTokens(len(string), max_k)

        N = len(string)
        for n in range(N):
            for k in range(max_k):
                new_grid.set(n, k, old_grid.get(n,k))  # Copy the entire N x K.
                if k < min(max_k, N-n):  # Only store a string for sensical steps.
                    new_grid.setToken(n, k, string[n:n+(k+1)])

        return new_grid

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        raise NotImplementedError()


class DiscretiseScores(NestedScoreGenerator):
    """
    Quantises to a discrete amount of levels, uniformly spaced in the given interval.
    Values outside the interval are kept as-is.
    """

    def __init__(self, nested_generator: ViterbiStepScoreGenerator, minimum_score: float, maximum_score: float, discretisation_levels: int):
        super().__init__(nested_generator)
        assert minimum_score > -INFTY and maximum_score < +INFTY and discretisation_levels > 1

        self.min = minimum_score
        self.max = maximum_score
        self.levels = discretisation_levels

        # Precompute these
        self.bucket_thresholds      = np.linspace(start=self.min, stop=self.max, num=self.levels + 1)  # Not the same as discretisation levels. For example: levels = 3 has the levels 0.0, 0.5 and 1.0, but bucket boundaries 0, 0.33, 0.67, 1.0.
        self.bucket_to_value_factor = (self.max-self.min)/(self.levels-1)  # Linear scale to go from [0 ... self.levels-1], the bucket domain, to [min, max], the actual domain.

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        # Transform to discrete values (first to bucket numbers in {1 ... levels}, then to the corresponding values).
        bucket_ids = np.digitize(nested_scores.grid, self.bucket_thresholds)
        new_grid: np.ndarray = self.min + self.bucket_to_value_factor*(bucket_ids-1)

        # Reset whatever falls out of range (in particular: existing INFs), which numpy maps to 0 (too low) or len(boundaries) == len(buckets)+1 (too high).
        # Note: self.max also counts as falling out of the interval, but because we want it to just be self.max anyway, copying it is fine.
        reset_mask = (bucket_ids < 1) + (bucket_ids > self.levels+1)
        new_grid[reset_mask] = nested_scores.grid[reset_mask]

        nested_scores.grid = new_grid  # Need to return an object, not a Numpy array.


class VocabularyConstraint(NestedScoreGenerator):

    def __init__(self, nested_generator: ViterbiStepScoreGenerator, subword_vocabulary: Vocab, reset_value: float=0.0):
        super().__init__(nested_generator)
        self.vocab = subword_vocabulary
        self.default = reset_value


class VocabularyConstraintNone(VocabularyConstraint):

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        pass


class VocabularyConstraintExact(VocabularyConstraint):
    """
    Post-processor for a score grid that resets all steps that aren't allowed by the given subword vocabulary.
    """

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        for n in range(len(string)):
            for k in range(max_k):  # It doesn't really matter that for large n, n:n+k is the same string every iteration.
                if k >= len(string) - n or string[n:n+(k+1)] not in self.vocab:  # TODO: Preferably this would be `not self.hasType()` like for the Markov random tokeniser, but a constraint is not a tokeniser...
                    nested_scores.set(n, k, self.default)


from ....util.trie import PrefixTrie

class VocabularyConstraintAtLeastAll(VocabularyConstraint, ViterbiStepScoreGeneratorWithTokens):
    """
    A step is allowed if there is a subword in the vocab that is AT LEAST that step.
    Gives slightly more freedom than an exact constraint.
    """

    def __init__(self, nested_generator: ViterbiStepScoreGenerator, subword_vocabulary: Vocab, reset_value: float=0.0):
        super().__init__(nested_generator, subword_vocabulary, reset_value)  # Will resolve to the first subclass's __init__.

        # Compile vocabulary
        self.vocab_trie = PrefixTrie()
        for typ in subword_vocabulary:
            self.vocab_trie.add(typ)
        self.vocab_trie.compile()
        self.vocab_trie.compileRoots()

    def augmentScores(self, nested_scores: ViterbiStepScores, string: str, max_k: int):
        raise NotImplementedError()

    def generateGrid(self, string: str, max_k: int) -> ViterbiStepScoresWithTokens:
        old_grid = self.nested_generator.generateGrid(string, max_k)
        new_grid = ViterbiStepScoresWithTokens(len(string), max_k)

        N = len(string)
        for n in range(N):
            for k in range(max_k):
                # Copy data from old grid
                new_grid.set(n, k, old_grid.get(n,k))

                if k >= min(max_k, N-n):  # Don't look up nor store strings if you don't need to.
                    new_grid.set(n, k, self.default)
                else:
                    # Get vocab type that is at least the current step
                    step = string[n:n+(k+1)]
                    step_with_possible_suffix = self.vocab_trie.getNodesWithPrefix(step, only_first=True)
                    if not step_with_possible_suffix:
                        new_grid.set(n, k, self.default)
                    else:
                        new_grid.setToken(n, k, step_with_possible_suffix[0].root)

        return new_grid
